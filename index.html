<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Knight In Shining Armor!</title>
</head>
<body>
    <script>
        const Knight = function(array) {
            this.position = array;
            this.moveSet = [];
            //consider Knight a Node (1st one can be assigned as gameBoard.root)
            //each Knight node can have a max of 8 possible moves aftewards
        }


        const Square = function(string) {
            this.name = string;
            this.visited = false;
            this.jumpNumber = null;
            this.previousSq = null;//type Node
        }

        const gameBoard = function() {
            this.consoleBoard = null;
            this.board = [];
            this.boolean = null;
            this.root = null;//type Node; will be initial Knight starting position
            buildBoard = () => {
                let cols = 7;
                let rows = 7;
                for(let i = 0; i<=cols; i++){
                    for (let j = 0; j<=rows; j++) {
                        let newSqName = `x${j}y${i}`;
                        let newSquare = new Square(newSqName);
                        this.board.push(newSquare);
                    }
                }
                return;
            }

            buildConsoleBoard = () => {
                let cols = 7;
                let rows = 7;
                let boardStr= '';
                for(let i = 0; i<=cols; i++){
                    for (let j = 0; j<=rows; j++) {
                        boardStr += '[o]';
                    }
                    boardStr += '\n';
                }
                this.consoleBoard = boardStr;
                return boardStr;
            }

            function initialPossibleMove(array) {//array = "starting position", x & y value; ex: [3,3]
                let x = array[0];
                let y = array[1];
                //create all 8 possible positions that knight can move to
                let newX1 = x - 1;
                let newY1 = y + 2;
                let firstMove = [newX1, newY1];
                let newX2 = x - 2;
                let newY2 = y + 1;
                let secondMove = [newX2, newY2];
                let newX3 = x - 2;
                let newY3 = y - 1;
                let thirdMove = [newX3, newY3];
                let newX4 = x - 1;
                let newY4 = y - 2;
                let fourthMove = [newX4, newY4];
                let newX5 = x + 1;
                let newY5 = y - 2;
                let fifthMove = [newX5, newY5];
                let newX6 = x + 2;
                let newY6 = y - 1;
                let sixthMove = [newX6, newY6];
                let newX7 = x + 2;
                let newY7 = y + 1;
                let seventhMove = [newX7, newY7];
                let newX8 = x + 1;
                let newY8 = y + 2;
                let eighthMove = [newX8, newY8];
                let all8PossibleMoves = [firstMove, secondMove, thirdMove, fourthMove, fifthMove, sixthMove, seventhMove, eighthMove];
                console.log("all8PossibleMoves are ", all8PossibleMoves);
                let index = all8PossibleMoves.length - 1;
                while (index >= 0) {
                    if (all8PossibleMoves[index][0] < 0 || all8PossibleMoves[index][0] > 7 || 
                    all8PossibleMoves[index][1] < 0 || all8PossibleMoves[index][1] > 7) {
                        all8PossibleMoves.splice(index, 1);
                    }
                    index--;
                }
                let legalMoves = all8PossibleMoves;//after reverse while loop, moves that go off the board are removed
                console.log("legalMoves are ", legalMoves);
                //narrow down to only squares that have NOT been visited
                let squareIndex = legalMoves.length - 1;
                while (squareIndex >= 0) {
                    if (findSquare(legalMoves[squareIndex]).visited === true) {
                        legalMoves.splice(squareIndex, 1);
                    }
                    squareIndex--;
                }
                let freeLegalMoves = legalMoves;
                console.log("freeLegalMoves are ", freeLegalMoves);
                return freeLegalMoves;//type Array
            }

            findSquare = (array) => {
                let nameToSearch = 'x'+array[0]+'y'+array[1];
                let foundSquare = this.board.find(el => el.name===`${nameToSearch}`);
                return foundSquare;
            }

            setStartNode = (array) => {
                this.root = new Knight(array);
            }

            fillingMovesIterator = () => {

                let counter = 0;
                let testArray = [];

                iteratingFxn = (node) => {//input type Node
                    let someArray = [];
                    let nodeSq = findSquare(node.position);
                    let firstMoves = initialPossibleMove(node.position);
                    if (firstMoves.length > 0) {//if this node has possible moves/child nodes
                        firstMoves.forEach(el => {
                            //create a new "Knight" Node
                            let newKnight = new Knight(el);
                            someArray.push(newKnight);
                            //push said Node into moveSet of root Knight so it's traceable 
                            node.moveSet.push(newKnight);
                            //find corresponding square for new Knight/jump iteration
                            let correspondingSq = findSquare(el);
                            correspondingSq.previousSq = nodeSq;
                            //mark that square visited along with the # of jumps it took to get there
                            correspondingSq.visited = true;
                            correspondingSq.jumpNumber = counter;
                        })
                    } 
                    return someArray;
                }

                let startNode = this.root;
                testArray.push(startNode);
                //first "iteration" is which squares can be reached w/ 0 jumps
                //AKA only the start square/block
                //first node, 1st level, 0 moveSets in
                let firstSq = findSquare(startNode.position);
                firstSq.visited = true;
                firstSq.jumpNumber = 0;
                counter++;

                function anotherBreadth(inputArray) {
                    let array2 = [];
                    if (inputArray.length > 0) {
                        let length1 = inputArray.length - 1;

                        let a = 0;
                        do {
                            let newArrays = iteratingFxn(inputArray[a]);
                            console.log("newArrays is: ", newArrays);
                            if (newArrays.length > 0) {
                                array2 = array2.concat(newArrays);
                            }
                            a++;
                        } while (a < length1)

                        /* for (let a = 0; a < length1; a++) {
                            let newArrays = iteratingFxn(inputArray[a]);
                            //console.log("newArrays is: ", newArrays);
                            if (newArrays.length > 0) {
                                array2 = array2.concat(newArrays);
                            }
                        } */
                    counter++;
                    console.log("array2 is: ", array2);
                    };
                    return array2;
                }

                let secondIt = anotherBreadth(testArray);
                console.log("secondIt: ", secondIt);
                let thirdIt = anotherBreadth(secondIt);
                console.log("thirdIt: ", thirdIt);
                let fourthIt = anotherBreadth(thirdIt);
                console.log("fourthIt: ", fourthIt);
                let fifthIt = anotherBreadth(fourthIt);
                console.log("fifthIt: ", fifthIt);
                let sixthIt = anotherBreadth(fifthIt);
                console.log("sixthIt: ", sixthIt);
                let seventhIt = anotherBreadth(sixthIt);
                console.log("seventhIt: ", seventhIt);
                let eighthIt = anotherBreadth(seventhIt);
                console.log("eighthIt: ", eighthIt);

                
                /* 
                //2nd "iteration" is which sq w/ 1 jump
                //if not on the edge, this is 8 children of initial root/start
                //2nd "level" nodes, 1 moveSet in
                let array1 = iteratingFxn(startNode);
                counter++;
                //console.log("array1 is: ", array1);
 
                //3rd - squares w/ 2 jumps
                //find possible moves of each child within root Knight moveSet
                //3rd "level" nodes, 2 moveSets in


                let array2 = [];
                if (array1.length > 0) {
                    let length1 = array1.length - 1;
                    for (let a = 0; a < length1; a++) {
                        let newArrays = iteratingFxn(array1[a]);
                        //console.log("newArrays is: ", newArrays);
                        if (newArrays.length > 0) {
                            array2 = array2.concat(newArrays);
                        }
                    }
                counter++;
                console.log("array2 is: ", array2);
                };

                //4th - 3 jumps squares
                //4th "level" nodes, 3 moveSets in
                let array3 = [];
                if (array2.length > 0) {
                    let length2 = array2.length - 1;
                    for (let b = 0; b < length2; b++) {
                        let newArrays = iteratingFxn(array2[b]);
                        //console.log("newArrays is: ", newArrays);
                        if (newArrays.length > 0) {
                            array3 = array3.concat(newArrays);
                        }
                    }
                counter++;
                console.log("array3 is: ", array3);
                }

                //5th - 4 jumps squares
                let array4 = [];
                if (array3.length > 0) {
                    let length3 = array3.length - 1;
                    for (let c = 0; c < length3; c++) {
                        let newArrays = iteratingFxn(array3[c]);
                        //console.log("newArrays is: ", newArrays);
                        if (newArrays.length > 0) {
                            array4 = array4.concat(newArrays);
                        }
                    }
                counter++;
                console.log("array4 is: ", array4);
                }

                //6th - 5 jumps
                let array5 = [];
                if (array4.length > 0) {
                    let length4 = array4.length - 1;
                    for (let d = 0; d < length4; d++) {
                        let newArrays = iteratingFxn(array4[d]);
                        //console.log("newArrays is: ", newArrays);
                        if (newArrays.length > 0) {
                            array5 = array5.concat(newArrays);
                        }
                    }
                counter++;
                console.log("array5 is: ", array5);
                }

                //7th - 6 jumps
                let array6 = [];
                if (array5.length > 0) {
                    let length5 = array5.length - 1;
                    for (let e = 0; e < length5; e++) {
                        let newArrays = iteratingFxn(array5[e]);
                        //console.log("newArrays is: ", newArrays);
                        if (newArrays.length > 0) {
                            array6 = array6.concat(newArrays);
                        }
                    }
                counter++;
                console.log("array6 is: ", array6);
                }

                //8th - 7 jumps
                let array7 = [];
                if (array6.length > 0) {
                    let length6 = array6.length - 1;
                    for (let f = 0; f < length6; f++) {
                        let newArrays = iteratingFxn(array6[f]);
                        //console.log("newArrays is: ", newArrays);
                        if (newArrays.length > 0) {
                            array7 = array7.concat(newArrays);
                        }
                    }
                counter++;
                console.log("array7 is: ", array7);
                } */
            }

            function targetSqToStart(targetSquare, array) {

                let initStrSplit = targetSquare.name.split("");
                let position = [Number(initStrSplit[1]), Number(initStrSplit[3])];
                array.push(position);

                if (targetSquare.previousSq === null) {
                    return array;
                } else {
                    return targetSqToStart(targetSquare.previousSq, array);
                }
            }

            knightMoves = (array) => {//input is [x,y]

                let targetSq = findSquare(array);
                let numberOfJumps = targetSq.jumpNumber;
                console.log(`Starting position: [${this.root.position}]; target: [${array}]`);
                console.log(`You made it in ${numberOfJumps} move(s)! Here's the path:`);
                let holderArray = [];
                let arrayToFlip = targetSqToStart(targetSq, holderArray);
                let length = arrayToFlip.length - 1;
                for (let i = length; i >= 0; i--) {
                    console.log(arrayToFlip[i]);
                }
            }

            driverFunct = () => {
                let startingPos = [0,0]; //--------------CHANGE START POINT (pls keep within board)
                buildConsoleBoard();
                //console.log(firstBoard.consoleBoard);
                buildBoard();
                //console.log(firstBoard.board);
                setStartNode(startingPos);//makes a Knight node for this.root

                fillingMovesIterator();
                console.log(firstBoard.board);
                console.log("root Knight: ", this.root);
                knightMoves([7,6]); //------------------CHANGE TARGET POINT (pls keep within board)
                
            }
        }

        const firstBoard = new gameBoard();
        driverFunct();
    </script>
</body>
</html>
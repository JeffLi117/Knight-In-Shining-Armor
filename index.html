<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Knight In Shining Armor!</title>
</head>
<body>
    <script>
        const Knight = function(array) {
            this.position = array;
            this.moveSet = [];
            //consider Knight a Node (1st one can be assigned as gameBoard.root)
            //each Knight node can have a max of 8 possible moves aftewards
        }


        const Square = function(string) {
            this.name = string;
            this.visited = false;
            this.jumpNumber = null;
            this.previousSq = null;//type Node
        }

        const gameBoard = function() {
            this.consoleBoard = null;
            this.board = [];
            this.boolean = null;
            this.root = null;//type Node; will be initial Knight starting position
            buildBoard = () => {
                let cols = 7;
                let rows = 7;
                for(let i = 0; i<=cols; i++){
                    for (let j = 0; j<=rows; j++) {
                        let newSqName = `x${j}y${i}`;
                        let newSquare = new Square(newSqName);
                        this.board.push(newSquare);
                    }
                }
                return;
            }

            buildConsoleBoard = () => {
                let cols = 7;
                let rows = 7;
                let boardStr= '';
                for(let i = 0; i<=cols; i++){
                    for (let j = 0; j<=rows; j++) {
                        boardStr += '[o]';
                    }
                    boardStr += '\n';
                }
                this.consoleBoard = boardStr;
                return boardStr;
            }

            function initialPossibleMove(array) {//array = "starting position", x & y value; ex: [3,3]
                let x = array[0];
                let y = array[1];
                //create all 8 possible positions that knight can move to
                let newX1 = x - 1;
                let newY1 = y + 2;
                let firstMove = [newX1, newY1];
                let newX2 = x - 2;
                let newY2 = y + 1;
                let secondMove = [newX2, newY2];
                let newX3 = x - 2;
                let newY3 = y - 1;
                let thirdMove = [newX3, newY3];
                let newX4 = x - 1;
                let newY4 = y - 2;
                let fourthMove = [newX4, newY4];
                let newX5 = x + 1;
                let newY5 = y - 2;
                let fifthMove = [newX5, newY5];
                let newX6 = x + 2;
                let newY6 = y - 1;
                let sixthMove = [newX6, newY6];
                let newX7 = x + 2;
                let newY7 = y + 1;
                let seventhMove = [newX7, newY7];
                let newX8 = x + 1;
                let newY8 = y + 2;
                let eighthMove = [newX8, newY8];
                let all8PossibleMoves = [firstMove, secondMove, thirdMove, fourthMove, fifthMove, sixthMove, seventhMove, eighthMove];
                console.log("all8PossibleMoves are ", all8PossibleMoves);
                let index = all8PossibleMoves.length - 1;
                while (index >= 0) {
                    if (all8PossibleMoves[index][0] < 0 || all8PossibleMoves[index][0] > 7 || 
                    all8PossibleMoves[index][1] < 0 || all8PossibleMoves[index][1] > 7) {
                        all8PossibleMoves.splice(index, 1);
                    }
                    index--;
                }
                let legalMoves = all8PossibleMoves;//after reverse while loop, moves that go off the board are removed
                console.log("legalMoves are ", legalMoves);
                //narrow down to only squares that have NOT been visited
                let squareIndex = legalMoves.length - 1;
                while (squareIndex >= 0) {
                    if (findSquare(legalMoves[squareIndex]).visited === true) {
                        legalMoves.splice(squareIndex, 1);
                    }
                    squareIndex--;
                }
                let freeLegalMoves = legalMoves;
                console.log("freeLegalMoves are ", freeLegalMoves);
                return freeLegalMoves;//type Array
            }

            findSquare = (array) => {
                let nameToSearch = 'x'+array[0]+'y'+array[1];
                let foundSquare = this.board.find(el => el.name===`${nameToSearch}`);
                return foundSquare;
            }

            setStartNode = (array) => {
                this.root = new Knight(array);
            }

            fillingMovesIterator = () => {

                let counter = 0;

                iteratingFxn = (node) => {//input type Node
                    let nodeSq = findSquare(node.position);
                    let firstMoves = initialPossibleMove(node.position);
                    firstMoves.forEach(el => {
                    //create a new "Knight" Node
                    let newKnight = new Knight(el);
                    //push said Node into moveSet of root Knight so it's traceable 
                    node.moveSet.push(newKnight);
                    //find corresponding square for new Knight/jump iteration
                    let correspondingSq = findSquare(el);
                    correspondingSq.previousSq = nodeSq;
                    //mark that square visited along with the # of jumps it took to get there
                    correspondingSq.visited = true;
                    correspondingSq.jumpNumber = counter;
                    })
                }

                let startNode = this.root;
                //first "iteration" is which squares can be reached w/ 0 jumps
                //AKA only the start square/block
                //first node, 1st level, 0 moveSets in
                let firstSq = findSquare(startNode.position);
                firstSq.visited = true;
                firstSq.jumpNumber = 0;
                counter++;
                
                //2nd "iteration" is which sq w/ 1 jump
                //if not on the edge, this is 8 children of initial root/start
                //2nd "level" nodes, 1 moveSet in
                iteratingFxn(startNode);
                counter++;

                //3rd - squares w/ 2 jumps
                //find possible moves of each child within root Knight moveSet
                //3rd "level" nodes, 2 moveSets in
                startNode.moveSet.forEach(ek => {//for each Node within an array of Nodes
                    iteratingFxn(ek);
                })
                counter++;

                //4th - 3 jumps squares
                //4th "level" nodes, 3 moveSets in
                let startMoveSetLength = startNode.moveSet.length - 1;
                for (let i = 0; i < startMoveSetLength; i++) {
                    if (startNode.moveSet[i].moveSet.length === 0) {
                        return;
                    } else {
                        startNode.moveSet[i].moveSet.forEach(ej => {
                            iteratingFxn(ej);
                        })
                    }
                }
                counter++;

                //5th - 4 jumps; not many left
                for (let i = 0; i < startMoveSetLength; i++) {
                    if (startNode.moveSet[i].moveSet.length === 0) {
                        return;
                    } else {
                        let innerMoveSetLength = startNode.moveSet[i].moveSet.length - 1;
                        for (let k = 0; k < innerMoveSetLength; k++) {
                            if (startNode.moveSet[i].moveSet[k].moveSet.length === 0) {
                                return;
                            } else {
                                startNode.moveSet[i].moveSet[k].moveSet.forEach(em => {
                                iteratingFxn(em);
                                }) 
                            }
                        }
                    }
                }
            }

            function targetSqToStart(targetSquare, array) {

                let initStrSplit = targetSquare.name.split("");
                let position = [Number(initStrSplit[1]), Number(initStrSplit[3])];
                array.push(position);

                if (targetSquare.previousSq === null) {
                    return array;
                } else {
                    return targetSqToStart(targetSquare.previousSq, array);
                }
            }

            knightMoves = (array) => {//input is [x,y]

                let targetSq = findSquare(array);
                let numberOfJumps = targetSq.jumpNumber;
                console.log(`Starting position: [${this.root.position}]; target: [${array}]`);
                console.log(`You made it in ${numberOfJumps} move(s)! Here's the path:`);
                let holderArray = [];
                let arrayToFlip = targetSqToStart(targetSq, holderArray);
                let length = arrayToFlip.length - 1;
                for (let i = length; i >= 0; i--) {
                    console.log(arrayToFlip[i]);
                }
            }

            driverFunct = () => {
                let startingPos = [3,3]; //--------------CHANGE START POINT
                buildConsoleBoard();
                //console.log(firstBoard.consoleBoard);
                buildBoard();
                //console.log(firstBoard.board);
                setStartNode(startingPos);//makes a Knight node for this.root

                fillingMovesIterator();
                console.log(firstBoard.board);
                console.log("root Knight: ", this.root);
                knightMoves([4,3]); //------------------CHANGE TARGET POINT
            }
        }

        const firstBoard = new gameBoard();
        driverFunct();
    </script>
</body>
</html>
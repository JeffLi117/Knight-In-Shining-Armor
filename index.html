<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Knight In Shining Armor!</title>
</head>
<body>
    <script>
        const Knight = function(array) {
            this.position = array;
            this.squareSittingOn = null;
            this.moveSet = [];
            //consider Knight a Node (1st one can be assigned as gameBoard.root)
            //each Knight node can have a max of 8 possible moves aftewards
        }


        const Square = function(string) {
            this.name = string;
            this.visited = null;
        }

        const gameBoard = function() {
            this.consoleBoard = null;
            this.board = [];
            this.root = null;//type Node; will be initial Knight starting position
            buildBoard = () => {
                let cols = 7;
                let rows = 7;
                for(let i = 0; i<=cols; i++){
                    for (let j = 0; j<=rows; j++) {
                        let newSqName = `x${j}y${i}`;
                        let newSquare = new Square(newSqName);
                        this.board.push(newSquare);
                    }
                }
                return;
            }

            buildConsoleBoard = () => {
                let cols = 7;
                let rows = 7;
                let boardStr= '';
                for(let i = 0; i<=cols; i++){
                    for (let j = 0; j<=rows; j++) {
                        boardStr += '[o]';
                    }
                    boardStr += '\n';
                }
                this.consoleBoard = boardStr;
                return boardStr;
            }

            function initialPossibleMove(array) {//array = "starting position", x & y value; ex: [3,3]
                let x = array[0];
                let y = array[1];
                //create all 8 possible positions that knight can move to
                let newX1 = x - 1;
                let newY1 = y + 2;
                let firstMove = [newX1, newY1];
                let newX2 = x - 2;
                let newY2 = y + 1;
                let secondMove = [newX2, newY2];
                let newX3 = x - 2;
                let newY3 = y - 1;
                let thirdMove = [newX3, newY3];
                let newX4 = x - 1;
                let newY4 = y - 2;
                let fourthMove = [newX4, newY4];
                let newX5 = x + 1;
                let newY5 = y - 2;
                let fifthMove = [newX5, newY5];
                let newX6 = x + 2;
                let newY6 = y - 1;
                let sixthMove = [newX6, newY6];
                let newX7 = x + 2;
                let newY7 = y + 1;
                let seventhMove = [newX7, newY7];
                let newX8 = x + 1;
                let newY8 = y + 2;
                let eighthMove = [newX8, newY8];
                let all8PossibleMoves = [firstMove, secondMove, thirdMove, fourthMove, fifthMove, sixthMove, seventhMove, eighthMove];
                console.log("all8PossibleMoves are ", all8PossibleMoves);
                let index = all8PossibleMoves.length - 1;
                while (index >= 0) {
                    if (all8PossibleMoves[index][0] < 0 || all8PossibleMoves[index][0] > 7 || 
                    all8PossibleMoves[index][1] < 0 || all8PossibleMoves[index][1] > 7) {
                        all8PossibleMoves.splice(index, 1);
                    }
                    index--;
                }
                let legalMoves = all8PossibleMoves;//after reverse while loop, moves that go off the board are removed
                console.log("legalMoves are ", legalMoves);
                //narrow down to only squares that have NOT been visited
                let squareIndex = legalMoves.length - 1;
                while (squareIndex >= 0) {
                    if (findSquare(legalMoves[squareIndex]).visited === true) {
                        legalMoves.splice(squareIndex, 1);
                    }
                    squareIndex--;
                }
                let freeLegalMoves = legalMoves;
                console.log("freeLegalMoves are ", freeLegalMoves);
                return freeLegalMoves;//type Array
            }

            findSquare = (array) => {
                let nameToSearch = 'x'+array[0]+'y'+array[1];
                let foundSquare = this.board.find(el => el.name===`${nameToSearch}`);
                return foundSquare;
            }

            setStartNode = (array) => {
                this.root = new Knight(array);
            }

            /* moveTesting = (node, target) => {//start @ [3,3] target [5,4]
                if (node.position[0] === target[0] && node.position[1] === target[1]) {//can't check array === array
                    console.log("We found a matching target!");
                    return;
                } else {
                    makeNextMoveNodes(node);

                    let startNodeArray = node.position;//take node's position array
                    console.log("node's position array within moveTesting: ", startNodeArray);
                    let firstArray = initialPossibleMove(startNodeArray);//legal moves array
                    firstArray.forEach(el => {//makes new Nodes for all initial possible moves
                        let newKnight = new Knight(el);
                        //console.log(newKnight);
                        node.moveSet.push(newKnight);
                    })
                    console.log("This iteration's node legal moves within moveTesting: ", node);
                    //node.moveSet.forEach(knight => {//type Node
                    //    moveTesting(knight, target);
                    //})
                    return node;//returns node with moveSet of legal moves
                }
                
            } */

            levelOrderWithin = (node, Qarray, target) => {
                //array = Q
                Qarray.push(node); //push first node (startNode/root)

                /* console.log("Qarray is ", Qarray);
                let doNode = Qarray[0]; //type Node
                let doNodeArray = doNode.moveSet;
                console.log("for this iteration, doNode is ", doNode);
                console.log("doNodeArray is ", doNodeArray); */

                //----------------
                //everything within this part, I want to do again
                //for each node I access within the Q
                let i = 0;
                do {
                    let doNode = Qarray[i]; //type Node
                    console.log("for this iteration, doNode is ", doNode);
                    doNode.squareSittingOn.visited = true;
                    if (doNode.position[0] === target[0] && doNode.position[1] === target[1]) {//can't check array === array
                        console.log("We found a matching target!");
                        return doNode;
                    } else {
                        let doNodeArray = doNode.moveSet;
                        if (doNodeArray.length !== 0) {//if there is something within moveSet
                            doNodeArray.forEach(el => {//take each element (type Node) and push it into Q
                                //console.log("element pushed is ", el);
                                Qarray.push(el);
                            })
                        }
                    }
                    //moves to next node in Q
                    i++;
                } while (i < Qarray.length);

                let qLength = Qarray.length - 1;
                while (qLength >= 0) {
                    if (Qarray[qLength].moveSet.length !== 0) {//something within moveSet, don't need it in the Q
                        Qarray.splice(qLength, 1);
                    }
                    qLength--;
                }

                return Qarray;
            }       

            buildTree = (targetSpace) => {//build tree from start node
                //make first level of children, check if any node equals targetSpace (type Array)
                //if not, repeat until target is reached 
                let startNode = this.root;
                let queueArray = [];
                let testResult = breadthFirst(startNode, queueArray, targetSpace);
                //console.log(testResult);

                return;
                ////-----------------Want to do all this again IF checkBreadth does NOT return a Node
                //for each node/step/level, create their child nodes 
                /* let childNodesMade = makeNextMoveNodes(startNode);//returns same node w/ populated moveSet
                console.log("childNodesMade: ", childNodesMade); */
                //THEN, breadth first, check that same level for if any of the child nodes match targetSpace
                /* let checkBreadth = levelOrderWithin(childNodesMade, queueArray, targetSpace);
                //levelOrderWithin will search childNodesMade & its moveSet; will go breadth first
                //if node that matches targetSpace is found, returns said node
                //otherwise, returns null
                console.log(checkBreadth);
                 */
                ////----------------
            }

            checkNodesQ = (array, target) => {
                let length = array.length - 1;
                for (let i = 0; i < length; i++) {
                    let childNodesMade = makeNextMoveNodes(array[i]);
                    console.log("childNodesMade in checkNodesQ: ", childNodesMade);
                    let checkingChildNodes = checkChildrenNodes(childNodesMade, target);
                    if (checkingChildNodes !== null) {
                        return;
                    }
                }
            }

            checkChildrenNodes = (node, target) => {
                let numberOfChildrenNodes = node.moveSet.length - 1;
                for (let i = 0; i < numberOfChildrenNodes; i++) {
                    console.log("checking node : ", node.moveSet[i]);
                    node.moveSet[i].squareSittingOn.visited = true;
                    if (node.moveSet[i].position[0] === target[0] && node.moveSet[i].position[1] === target[1])
                    return node.moveSet[i];
                }
                return null;
            }

            function breadthFirst(startingNode, array, target) {
                startingNode.squareSittingOn = findSquare(startingNode.position);
                let childNodesMade = makeNextMoveNodes(startingNode);//returns same node w/ populated moveSet
                //moveSet will only allow squares that have NOT been visited (& on the board)
                console.log("childNodesMade: ", childNodesMade);
                let updatedQ = levelOrderWithin(childNodesMade, array, target);
                console.log(updatedQ); //returns Q after de-Q'ing any that have a moveSet (don't need to iterate it again)
                
                checkNodesQ(updatedQ, target);
                    //for each child Node within startingNode's moveSet
                    //I want to ONLY makeNextMoveNodes & levelOrderWithin it once
                    //if both of those go through without incident
                    //after passing ALL of startingNode's initial moveSet
                    //then I can go "deeper" into the children of init moveSet
                    
                ////////need to find a way (maybe without forEach) so that the BREADTH portion will happen
                //before it goes deeper within the loop and keeps going....
                
            }
            //takes node; creates array from initialPossibleMove(node.position) & 
            makeNextMoveNodes = (node) => {//adds children "next moves" nodes from said array to node

                let array = initialPossibleMove(node.position);
                array.forEach(el => {
                    let newChild = new Knight(el);
                    let foundSquare = findSquare(el);
                    newChild.squareSittingOn = foundSquare;
                    node.moveSet.push(newChild);
                })
                return node;
            }

            knightMoves = (startBlock, endBlock) => {
                this.root = new Knight(startBlock);
                console.log("Moving to...");
            }
            driveFunct = () => {
                let startingPos = [3,3];
                let targetSpace = [6,6];
                buildConsoleBoard();
                //console.log(firstBoard.consoleBoard);
                buildBoard();
                //console.log(firstBoard.board);
                setStartNode(startingPos);//makes a Knight node for this.root
                console.log("root Knight: ", this.root);
                
                //makeNextMoveNodes(this.root);
                buildTree(targetSpace);
                console.log(this.root);
            }
        }

        //knightMoves([1,2]);
        const firstBoard = new gameBoard();
        driveFunct();
    </script>
</body>
</html>